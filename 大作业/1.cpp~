#include<algorithm>
#include<iostream>
using namespace std;

int cmp(const void *a,const void *b){
    return *(int*)a-*(int*)b;
}

void inputHandle(int &n,int &m,int* &income,int* &presum){
    scanf("%d%d",&n,&m);
    income = new int[n];
    presum = new int[n+1];
    presum[0]=0;
    for (int* i = income; i < income+n; i++)
        scanf("%d",i);
}

int binarySearch(int *arr,int l,int r,int target,bool mode){
    register int left=l,right=r;
    register int mid;
    while(left<right){
        mid = (left+right)>>1;
        if(arr[mid]<target){
            left=mid+1;
        }
        else if(arr[mid]>target){
            right=mid;
        }
        else{
            //处理重复数据的方式
            if(mode){               //区间最右
                right=r;
                while(mid<right&&arr[mid]==target)
                    ++mid;
            }
            else{                   //区间最左
                left=l;
                while(mid>=left&&arr[mid-1]==target)
                    --mid;
            }   
            return mid;
        }
    }
    //target不在arr中
	//选择区间最右
    if(arr[mid]<target&&mid<r)
    	++mid;
    
	return mid;     
}


int check(int n,int m,int *income,int *presum){
    int l,r;
    int leftAddr,rightAddr;
    for(int i=0;i<m;i++){
        cin>>l>>r;
        //所有的区间都是[l,r)
        leftAddr=binarySearch(income,0,n,l,0);
        rightAddr=binarySearch(income,0,n,r,1);
        
        int num=rightAddr-leftAddr;
        if(num==0)
            printf("0\n");
        else{
      	    cout<<leftAddr<<' '<<rightAddr<<endl;
            printf("%d\n",(presum[rightAddr]-presum[leftAddr])/num);
        } 
           
    }
}



int main(){
    ios::sync_with_stdio(false);
    int n,m;
    int *income,*presum;
    inputHandle(n,m,income,presum);
    sort(income,income+n);
    for(int i=0;i<n;i++){  // get presum
        presum[i+1]=presum[i]+income[i];
    }
    check(n,m,income,presum);

    return 0;
}
/*
10 3
1 2 3 4 5 5 5 8 40 40

10 5
100
40
30
60
30
30
40
40
60
200

*/
